1
00:00:00,000 --> 00:00:04,110
英雄图鉴 -- 使用漫威 API 
（翻译：Ben.imbushuo Wang，审核：章程）

2
00:00:04,110 --> 00:00:06,109
各位好，你们知道在视频中，我将先

3
00:00:06,110 --> 00:00:10,889
着手处理应用中最麻烦的内容

4
00:00:10,890 --> 00:00:13,249
在本例子中

5
00:00:13,250 --> 00:00:15,809
我感觉到，一路上我们会遇到很多麻烦的事情

6
00:00:15,810 --> 00:00:18,989
正因为如此，我也就先从处理这些事情开始。

7
00:00:18,990 --> 00:00:21,589
我认为我们会遇到的第一件事情是

8
00:00:21,590 --> 00:00:27,530
了解如何调用漫威动画的API并取得其返回的信息。

9
00:00:27,531 --> 00:00:32,190
接下来，反序列化(Deserialize)我们取得的任何信息到类的实例中

10
00:00:32,191 --> 00:00:35,050
然后在我们的应用程序中使用它们。

11
00:00:35,051 --> 00:00:41,269
接下来，我将介绍在你的应用里使用漫威动画API前你需要完成的那些事项：

12
00:00:41,270 --> 00:00:46,240
首先你需要注册一个开发者账号

13
00:00:46,241 --> 00:00:51,201
你可以看见我已经打开了 URL developer.marvel.com

14
00:00:51,202 --> 00:00:55,623
然后你会看到一个 “从这里开始” (Get Started) 的链接

15
00:00:55,624 --> 00:00:58,783
它将会带你完成整个注册流程。

16
00:00:58,784 --> 00:01:01,202
注册十分简单，你并不需要提供太多的信息

17
00:01:01,203 --> 00:01:09,039
他们只需要知道使用 API 的人和使用的理由

18
00:01:09,040 --> 00:01:15,059
因为他们在对使用 API 盈利这件事情上有所限制。

19
00:01:15,060 --> 00:01:24,959
我希望你完整阅读 （许可条款），并了解你可能会遇到的情况，特别是如果你在考虑在应用内使用漫威 API 并将其分发到应用商店的话。

20
00:01:24,960 --> 00:01:26,359
但是我并不是一个律师

21
00:01:26,360 --> 00:01:28,598
我将把这些事情留给你和漫威动画。

22
00:01:28,599 --> 00:01:32,439
在注册好开发者账户后

23
00:01:32,440 --> 00:01:36,519
接下来你可能想做的是学习一下如何使用它们。

24
00:01:36,520 --> 00:01:41,439
幸运的是，他们提供了很好的交互式文档。

25
00:01:41,440 --> 00:01:48,019
你可以看一下多种调用 API 的方法，以及你可以获取的信息。

26
00:01:48,020 --> 00:01:52,039
举个例子，你可以获得一个角色列表

27
00:01:52,040 --> 00:01:53,519
或是单个角色

28
00:01:53,520 --> 00:01:56,218
或是涉及到某角色的所有动画

29
00:01:56,219 --> 00:01:59,498
亦或是跟某个角色有关的事件、系列或是故事们。

30
00:01:59,499 --> 00:02:02,049
你可以甚至获得一个漫画列表。

31
00:02:02,050 --> 00:02:04,319
你可以用某些方法来筛选返回的内容

32
00:02:04,320 --> 00:02:06,599
你可以获得某本漫画

33
00:02:06,600 --> 00:02:07,999
或是此漫画中的所有角色

34
00:02:08,000 --> 00:02:11,478
或是此漫画的作者

35
00:02:11,479 --> 00:02:14,478
或是跟此漫画有关的所有事件和故事。

36
00:02:14,479 --> 00:02:16,178
你大概已经对此略有了解。

37
00:02:16,179 --> 00:02:21,559
接下来你看到的是高层次的应用程序接口调用概览

38
00:02:21,560 --> 00:02:29,119
你可以点击其中的某一个接口，学习这个接口的作用和它能返回给你的数据。

39
00:02:29,120 --> 00:02:43,659
在这个例子中，我猜你可以说这是在你调用这个 API 时会返回的模型(Model) ，和此信息有关的类和属性们。

40
00:02:43,660 --> 00:02:53,059
这里甚至有一个交互式环境来帮助你测试接口的输入参数。

41
00:02:53,060 --> 00:03:01,438
在接下来的输入样例中，我将请求接口并返回前十个名字以 SP 开头的漫画角色。

42
00:03:01,439 --> 00:03:05,738
你可以点击 Try it out! 按钮，它将会显示你所请求的URL

43
00:03:05,739 --> 00:03:14,539
在本例子中，你可以在上方看到 /slash/v1/public/characters

44
00:03:14,540 --> 00:03:22,402
并附上了地址前缀 gateway.marvel.com:80/v1

45
00:03:22,403 --> 00:03:30,141
最后，你可以看到传入的各类键值对的查询参数：

46
00:03:30,142 --> 00:03:34,241
NameStarts 等于Sp，limits 等于10

47
00:03:34,242 --> 00:03:39,222
最终你需要提供接口密钥，我们将稍后讨论本内容。

48
00:03:39,223 --> 00:03:42,082
然后我们得到了这个冗长的JSON。

49
00:03:42,083 --> 00:03:53,742
我们可以在最上方看到一些其他信息，表明这个操作成功了，它给了我们一个为200的返回值。

50
00:03:53,743 --> 00:04:00,982
如果操作失败了，我们也可以看到一些可能导致失败的原因。

51
00:04:00,983 --> 00:04:11,322
便于网页应用使用的，以HTML表示的attributionText已被添加

52
00:04:11,323 --> 00:04:16,323
我需要再次强调，根据你和漫威动画间的约定，你需要理解这些跟法律相关的内容

53
00:04:16,324 --> 00:04:20,063
但无论如何，我们得到了实际需要的结果

54
00:04:20,064 --> 00:04:30,083
在本例中，接口报告总共有33个角色符合查询要求，但是根据设定只返回了前10个角色。

55
00:04:30,084 --> 00:04:34,423
我们只返回了前十个名字以SP开头的角色。

56
00:04:34,424 --> 00:04:43,602
你可以看到第一个角色， Spacker Dave ，并没有描述，也没有预览图像。

57
00:04:43,603 --> 00:04:50,783
在一些情况下，不是特别出名的角色不会有很多信息。

58
00:04:50,784 --> 00:04:55,043
与之相反，有些角色会有特别多的信息。

59
00:04:55,044 --> 00:04:57,362
我们继续看一下……

60
00:04:57,363 --> 00:04:59,243
第二个角色Speed是个很好的例子。

61
00:04:59,244 --> 00:05:03,663
描述: Tommy Shephard might be the son of Scarlet Witch and The Vision. 嗯。

62
00:05:03,664 --> 00:05:09,682
这个角色也有预览图。属性 resourceURI 给了我们更多关于角色的具体信息

63
00:05:09,683 --> 00:05:13,803
接下来是这个角色在不同漫画中的出现次数

64
00:05:13,804 --> 00:05:21,202
在本例子中我们可以看到本角色在两个独立的漫画中出现。

65
00:05:21,203 --> 00:05:25,342
然后是他们在连载中出现的次数，以及涉及他们的故事。

66
00:05:25,343 --> 00:05:31,413
接下来是其他角色，例如 Speed Demon 。

67
00:05:31,414 --> 00:05:37,222
我们来讨论一下应用程序接口密钥。

68
00:05:37,223 --> 00:05:44,842
当你注册开发者账户时，你可以在最顶端查看你的开发者账户。

69
00:05:44,843 --> 00:05:48,502
你将获得一个公钥和一个私钥。

70
00:05:48,503 --> 00:05:59,603
在调用API时，多数情况下你将被要求仅传入公钥，就像你之前看到的那样；

71
00:05:59,604 --> 00:06:05,362
但是少数情况下你需要传入公钥和私钥的组合，我们将在稍后讨论。

72
00:06:05,363 --> 00:06:16,482
如果你是在网页端应用程序里使用这些接口，你需要指定你的应用程序接口调用来源。

73
00:06:16,483 --> 00:06:27,921
在本例中，用于获得信息的地址是 developer.marvel.com 。

74
00:06:27,922 --> 00:06:34,150
但是，如果你查看 How-To 章节下的授权流程

75
00:06:34,151 --> 00:06:39,410
你将会发现这只适用于基于浏览器构建的客户端应用程序（而不是基于非浏览器构建的应用端客户程序）。

76
00:06:39,411 --> 00:06:44,411
如果你在构建的是一个服务器端应用程序

77
00:06:44,412 --> 00:06:47,450
在我们的例子里，也就仅仅是一个客户端

78
00:06:47,451 --> 00:06:49,890
你需要提供更多的信息。

79
00:06:49,891 --> 00:06:53,570
事实上，你需要提供的是哈希值。

80
00:06:53,571 --> 00:07:01,291
在这里，哈希值是你的公私钥和请求时间戳的 MD5 摘要值。

81
00:07:01,292 --> 00:07:11,188
这里的哈希事实上就是一种基于只有双方知道的公私钥对的计算算法。

82
00:07:11,189 --> 00:07:22,388
事实上有很多哈希算法，MD5是其中比较弱的一个。

83
00:07:22,389 --> 00:07:30,248
但是更强的算法也意味着消耗更多计算资源。因此，在这里他们做了一个权衡。

84
00:07:30,240 --> 00:07:40,044
但最终的目的还是确保没有人盗用了你和服务器之间的请求。

85
00:07:40,088 --> 00:07:46,577
你需要做的是拿上你的公钥、私钥和时间戳

86
00:07:46,570 --> 00:07:52,266
然后你把这些值放到 md5 这个算法中

87
00:07:52,311 --> 00:07:58,644
最后你会得到一个哈希值。
每次我们调用漫威 API 的时候我们都会在后面加上这个哈希值。

88
00:07:58,644 --> 00:08:00,420
我们刚刚了解如何在 C# 里完成这一切操作。

89
00:08:00,421 --> 00:08:08,412
幸运的是，在 Universal Windows Platform 里的一些类将帮助我们完成这些操作。

90
00:08:08,413 --> 00:08:19,241
让我们回到交互式文档，讨论一下接下来我们的应用程序会做什么。

91
00:08:19,242 --> 00:08:25,442
我们将会创建一个叫 Hero Explorer 的应用程序。

92
00:08:25,443 --> 00:08:31,654
这个应用程序将从 Marvel Universe 里随机显示一些角色

93
00:08:31,655 --> 00:08:34,513
我们可以点击其中的某一个角色来了解关于该角色的更多信息。

94
00:08:34,514 --> 00:08:40,373
举个例子，很久以前我不知道某个叫 Speed的角色，以前他干了什么……

95
00:08:40,374 --> 00:08:49,054
就像我们这群 Geek 一样,，如果在人生中的某一点你对漫威动画产生了兴趣（想了解更多），这是不是很有意思？

96
00:08:49,055 --> 00:08:57,693
所以我想做的大概就是随机从漫威动画数据库里取十个角色。

97
00:08:57,694 --> 00:09:01,753
接下来我要做的是创建一个偏差值

98
00:09:01,754 --> 00:09:07,253
我知道数据库中个大概有 1,500 个角色。

99
00:09:07,254 --> 00:09:15,633
我将随机生成一个 1-1500 间的数字，比如 1490 ，称之为我的差值。

100
00:09:15,634 --> 00:09:20,375
以随机数字 520 为例，

101
00:09:20,376 --> 00:09:29,095
从 520 后在漫威的数据库中获得十个角色。

102
00:09:29,096 --> 00:09:32,235
因此我输入限制(Limit): 10，偏差值(Offset): 520

103
00:09:32,236 --> 00:09:35,494
让我们看看获得到什么。

104
00:09:35,495 --> 00:09:43,975
返回的结果以首字母正序排序。呀，返回了一个为 500 的状态码

105
00:09:43,976 --> 00:09:51,915
这表明在他们那里出现了一些问题。你可以重试，或是修改一些这里的请求

106
00:09:51,916 --> 00:09:55,314
我们把数值改成 350 并再试一次。

107
00:09:56,416 --> 00:09:59,055
嗯，这次看上去可以了。

108
00:09:59,056 --> 00:10:01,375
我并不确定发生了什么

109
00:10:01,376 --> 00:10:05,014
但是你通过某种办法使其工作了，对吧？

110
00:10:05,015 --> 00:10:08,035
在这个例子中，我们从字母 E 开始，

111
00:10:08,036 --> 00:10:12,014
我们看看 Earthquake ，我从来不知道这个角色

112
00:10:12,015 --> 00:10:20,679
接下来跟着的是 Echo

113
00:10:22,710 --> 00:10:26,209
然后是 Eddie Brock 。我们可以不管它们了。

114
00:10:26,210 --> 00:10:33,170
现在我们对如何调用 API 有所了解了

115
00:10:33,171 --> 00:10:41,820
接下来我们要做的是把返回的 JSON 转换到 C# 类。

116
00:10:41,821 --> 00:10:46,201
就像在我们做天气应用时调用 OpenWeatherMap API 那样。

117
00:10:46,202 --> 00:10:57,589
所以我需要做的是，寻找一个可以用于转换 JSON 到 C# 类的 JSON 样例。

118
00:10:57,590 --> 00:11:04,490
如果我用了一个没有太多返回结果的 JSON

119
00:11:04,491 --> 00:11:09,510
那我们就不一定能获得准确的转换到从 JSON 转换到 C# 的类。

120
00:11:09,511 --> 00:11:13,849
我要做的是就是输入大概是：

121
00:11:13,850 --> 00:11:17,889
Spider ，不对， Spiderman 。

122
00:11:17,890 --> 00:11:21,085
它返回了两个结果给我。

123
00:11:21,086 --> 00:11:25,345
我就得到了我需要的东西。

124
00:11:25,346 --> 00:11:31,745
它给了我一个良好的 JSON 范例来帮助我转换 JSON 到 C# 。

125
00:11:31,746 --> 00:11:35,905
接下来我们去掉偏差值再试一次。

126
00:11:35,906 --> 00:11:39,515
嗯，我得到了名字，很好的描述

127
00:11:39,516 --> 00:11:41,316
以及极好的预览图。

128
00:11:41,317 --> 00:11:52,176
这里所有枚举出来的信息，我对这个代码片段返回的所有信息感到满意。

129
00:11:52,177 --> 00:11:55,876
选中它们，按 Ctrl + C 复制到我的剪贴板里

130
00:11:55,877 --> 00:12:00,706
并前往 json2csharp.com 复制我的 JSON

131
00:12:00,707 --> 00:12:03,365
并点击“生成” (Generate)。

132
00:12:03,366 --> 00:12:12,526
我想强调一下为什么我需要得到一个有很多数据的角色 JSON 数据模板

133
00:12:12,527 --> 00:12:17,485
因为在 json2csharp.com 处理JSON时

134
00:12:17,486 --> 00:12:21,806
它将解析 JSON 并分析需要创建哪些类。

135
00:12:21,807 --> 00:12:29,865
如果缺失一些信息，它将使用一些通用的东西，比如 object ，而不是 character 。

136
00:12:29,866 --> 00:12:37,405
它也有可能会生成在我们的 JSON 模板里不存在的内容

137
00:12:37,406 --> 00:12:39,266
希望你理解了我说的内容。

138
00:12:39,267 --> 00:12:42,206
我将把这些内容复制到剪贴板

139
00:12:42,207 --> 00:12:45,285
打开 Visual Studio

140
00:12:45,286 --> 00:12:52,068
创建一个叫 HeroExplorer 的项目。

141
00:13:02,179 --> 00:13:12,744
然后我要做的第一件事情是创建一个叫 Model 的文件夹

142
00:13:12,745 --> 00:13:19,314
在这个文件夹中，我将创建一个类，名叫……

143
00:13:19,315 --> 00:13:20,774
好吧，我要做的是

144
00:13:20,775 --> 00:13:24,874
返回漫威开发者门户

145
00:13:24,875 --> 00:13:26,374
回到最上方

146
00:13:26,375 --> 00:13:29,074
我们可以看到回复的类。

147
00:13:29,075 --> 00:13:31,974
在最顶端，我们可以看到一个叫

148
00:13:31,975 --> 00:13:36,694
CharacterDataWrapper 和 CharacterDataContainer 的类。

149
00:13:36,695 --> 00:13:40,654
CharacterDataWrapper将会包含数据

150
00:13:40,655 --> 00:13:44,014
CharacterDataContainer将会包含结果。

151
00:13:44,015 --> 00:13:46,954
也就是一个 Character 类的数组。

152
00:13:46,955 --> 00:13:50,954
所以我就叫它 CharacterDataWrapper 吧。

153
00:13:57,225 --> 00:14:06,366
我将把从 json2csharp 得到的所有内容复制到这里。

154
00:14:06,367 --> 00:14:12,285
我将深入检查这里的内容

155
00:14:12,286 --> 00:14:16,346
比如这里有东西命名太通用化： 比如 "item"。

156
00:14:16,347 --> 00:14:22,586
事实上 "item" 是 Comics 类的一个实例，

157
00:14:22,587 --> 00:14:31,366
所以我现在要做的是把这个内容从 Item 重命名到 Comic ，

158
00:14:31,367 --> 00:14:35,546
所以 Comics 类将会包含一个类型为 Comic 的列表内容。

159
00:14:35,547 --> 00:14:37,226
对 Series 类，上述内容也适用。

160
00:14:37,227 --> 00:14:43,256
不幸的是，对 Series 此词取复数形式太过麻烦。

161
00:14:43,257 --> 00:14:49,368
所以我可能叫它 SeriesList 。

162
00:14:49,369 --> 00:14:59,864
因此就将其命名为 Series，然后 SeriesList 就会有一个 Series 的列表。

163
00:14:59,865 --> 00:15:02,423
上述事情也对 Stories 一样适用。

164
00:15:02,424 --> 00:15:05,343
所以这个将会成为 Story 类

165
00:15:05,344 --> 00:15:13,084
然后，在我们的 Stories 类里面，就会有一个 Story 类的列表叫 Items 。

166
00:15:13,085 --> 00:15:15,744
我们对 Events 类采取相同的操作。

167
00:15:15,745 --> 00:15:18,364
所以我们会将这个命名为 Event

168
00:15:18,365 --> 00:15:23,174
然后我们就会有一个 Events 类的列表叫 Items 。

169
00:15:24,555 --> 00:15:28,354
但是到我们看到最下面的这些内容后

170
00:15:28,355 --> 00:15:34,294
我目前真正想做的是重用漫威使用的命名。

171
00:15:34,295 --> 00:15:42,134
所以，我们将称呼这个最顶端的对象 CharacterDataWrapper 而不是 rootObject 。

172
00:15:42,135 --> 00:15:50,474
与之同时，我们在这里将会使用 CharacterDataContainer 这个名字。

173
00:15:53,327 --> 00:16:00,803
除此之外，我还看到每个独立角色是 Character类型的

174
00:16:00,804 --> 00:16:02,243
所以我也将改变这些内容

175
00:16:02,244 --> 00:16:05,783
所以这不是 result ，而是 Character 。

176
00:16:05,784 --> 00:16:09,223
所以我们也会有一个 Character 的列表。

177
00:16:09,224 --> 00:16:16,323
它将给返回给我们 CharacterDataContainer 的数据。

178
00:16:16,324 --> 00:16:19,602
接下来我希望深入检查，以确保各项内容正确。

179
00:16:19,603 --> 00:16:24,812
所以这个应该是 SeriesList 而不是 Series 。

180
00:16:24,813 --> 00:16:29,303
然后我需要花一点时间检查这里的内容

181
00:16:29,304 --> 00:16:31,098
我需要在此处特别小心

182
00:16:31,099 --> 00:16:38,338
因为我需要确保 JSON 在反序列化后这些类是可用的。

183
00:16:38,339 --> 00:16:42,838
(笑) 诊断不能工作的原因是很麻烦的。

184
00:16:42,839 --> 00:16:45,838
嗯，看上去没啥问题……

185
00:16:45,839 --> 00:16:49,618
嗯，我觉得在什么我们要做的下一件事情

186
00:16:49,619 --> 00:16:51,678
嗯……停一下！

187
00:16:51,679 --> 00:16:56,258
我们事实上要创建一个类。

188
00:16:56,259 --> 00:16:59,328
所以在这里，让我把这个设定到最顶端……

189
00:16:59,329 --> 00:17:02,666
然后添加一个类

190
00:17:02,667 --> 00:17:05,446
我需要一种编程访问漫威动画 API 的方法

191
00:17:05,447 --> 00:17:12,886
所以我将在这里创建 MarvelFacade

192
00:17:12,887 --> 00:17:18,347
Facade 是软件开发中的专有名词

193
00:17:18,348 --> 00:17:26,467
指代一种创建一层代码以包装你不可控制的内容的的设计模型。

194
00:17:26,468 --> 00:17:31,886
所以我们希望创建一种友好的方法来从 C# 里调用漫威的 API 。

195
00:17:31,887 --> 00:17:47,746
在幕后， MarvelFacade 将会处理调用，获取，解析并转换到我们的模型类的诸类繁杂琐事。

196
00:17:47,747 --> 00:17:57,807
MarvelFacade 也会包含一些私有的方法来帮助创建、构建传到漫威动画的 URL

197
00:17:57,808 --> 00:18:04,946
也不止 API 调用本身，也加上筛选参数，同时也

198
00:18:04,947 --> 00:18:15,846
包含我们传过去的 公钥、私钥和时间戳的 MD5 哈希值。

199
00:18:15,847 --> 00:18:22,706
所以我们把这个改成一个公开的静态类 (public static class) —— 好吧，我们把它只改称公开类 (public class)

200
00:18:22,707 --> 00:18:34,807
然后我们会创建一个公开的静态方法 (public static void) 叫 GetCharacterList 。

201
00:18:34,808 --> 00:18:44,369
我知道我需要用 HTTPClient 来做调用，我将

202
00:18:44,370 --> 00:18:50,168
通过到 “管理NuGet包” (Manage NuGet Packages) 来将其添加到我的包里。

203
00:18:50,169 --> 00:18:54,028
我将会搜索 ——

204
00:18:54,029 --> 00:18:58,269
我会在这里搜索什么呢？是 HTTPClient 。

205
00:18:58,270 --> 00:19:02,099
好， 我们只需要安装它。

206
00:19:07,149 --> 00:19:11,528
好的，就这样

207
00:19:11,529 --> 00:19:13,729
我认为这就是我在这个视频里所想完成的所有内容

208
00:19:13,730 --> 00:19:19,989
因为我希望保持视频短小精炼。

209
00:19:19,990 --> 00:19:23,729
让我们在这里停下吧，在下一个视频中

210
00:19:23,730 --> 00:19:32,408
我们将真正调用漫威动画并得到角色人物的 JSON 文件

211
00:19:32,409 --> 00:19:36,828
并反序列化到 CharacterDataWrapper 模型。

212
00:19:36,829 --> 00:19:39,336
那我们下个视频见。

213
00:19:39,330 --> 00:19:46,577
微软大法好

